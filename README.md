# Oscar::Activities

A small Rails engine for recording an audit trail across your application.
It captures who did what to which record and when, and ties each activity entry
back to a domain-specific "application activity" record that you control.

Core ideas:
- An Activity stores: actor (who), optional impersonated_by, target (what),
  target_event (what happened), and a reference to your application_activity record.
- actor, impersonated_by and target are polymorphic, so you can attach any model
  (e.g., User, Admin, Document, etc.).
- Application activities are enabled by default, can be toggled on/off per-thread in a block,
  or globally across the process.


## Installation
Add to your Gemfile and bundle:

```ruby
gem "oscar-activities", git: "https://github.com/BotyglotTeam/oscar-activities", branch: "main"
```

```bash
bundle
```

Run the installer generator, then migrate:

```bash
bin/rails g oscar:activities:install
bin/rails db:migrate
```

What the installer does:

- Copies the engine's migrations into your app (via `railties:install:migrations FROM=oscar_activities`).
- Creates `app/models/application_activity.rb`, an abstract base that subclasses `Oscar::Activities::ApplicationActivity`. Define your app-specific activity handlers by subclassing `ApplicationActivity`.
- Adds `spec/support/oscar_activities.rb` (for RSpec), which disables application activities by default in tests and re-enables them for feature specs and examples tagged with `require_application_activities`.

Note: If the gem ships new migrations in the future, re-run the installer or run:

```bash
bin/rails railties:install:migrations FROM=oscar_activities
```

You will also create tables for your own ApplicationActivity subclasses (see below).


## Defining an application activity
To capture events from your app, define a model that inherits from
ApplicationActivity (generated by the installer; it subclasses `Oscar::Activities::ApplicationActivity`). This model
persists your app-specific details and, after it is created, automatically creates the associated Activity.

1) Create a table for your application activity (you can add any fields you need):

```ruby
# db/migrate/2025xxxxxx_create_document_view_activities.rb
class CreateDocumentViewActivities < ActiveRecord::Migration[7.1]
  def change
    create_table :document_view_activities do |t|
      t.string :note
      t.timestamps
    end
  end
end
```

2) Define the model, subscribe to an event, and map payload to the audit fields:

```ruby
# app/models/document_view_activity.rb
class DocumentViewActivity < ApplicationActivity
  # Subscribe once to an ActiveSupport::Notifications event
  tracks "activities.document.viewed"

  # Called whenever the event fires
  def handle(event_name, started_at, finished_at, instrumenter_id, payload)
    self.actor           = payload[:actor]             # e.g., current_user
    self.impersonated_by = payload[:impersonated_by]   # optional
    self.target          = payload[:target]            # e.g., a Document
    self.target_event    = "viewed"                    # a short, app-defined label
    self                  # return self so it will be saved
  end
end
```

3) Emit the event from your application code:

```ruby
ActiveSupport::Notifications.instrument(
  "activities.document.viewed",
  actor: current_user,
  target: document,
  impersonated_by: current_admin_if_impersonating
)
```

When the event is instrumented, a DocumentViewActivity record is saved and an
Oscar::Activities::Activity entry is automatically created and linked to it.

Tip: You can also create your application activity directly if you are not using
ActiveSupport::Notifications for a particular case:

```ruby
DocumentViewActivity.create!(actor: current_user, target: document, target_event: "viewed")
# The associated Oscar::Activities::Activity is created after commit.
```


## Toggling audit processing
Application activities are ON by default. You can toggle them in a thread-safe way,
or globally:

- Thread-local, block-scoped helpers (previous state is restored at block end):

```ruby
Oscar::Activities.with_application_activities do
  # ON inside this block (regardless of previous state)
end

Oscar::Activities.without_application_activities do
  # OFF inside this block
end
```

- Global imperative API (applies across all threads until changed again):

```ruby
Oscar::Activities.disable_application_activities!
Oscar::Activities.enable_application_activities!
```

Nesting works as expected (inner block overrides the outer state temporarily).


## Querying activities
Activity entries are stored in Oscar::Activities::Activity. Some examples:

```ruby
# Most recent actions on a record
Oscar::Activities::Activity.where(target: document).order(created_at: :desc)

# Actions performed by a user
Oscar::Activities::Activity.where(actor: user)

# Actions of a certain type
Oscar::Activities::Activity.where(target_event: "viewed")
```


## Immutability
For safety, persisted records are readonly:
- Oscar::Activities::ApplicationActivity instances cannot be updated or destroyed after create.
- Oscar::Activities::Activity entries cannot be updated or destroyed after create.

If you need to change data, create a new record that reflects the new state.


## Notes
- tracks expects a String event name (e.g., "activities.something.happened").
- You can override .perform_handle?(...) on your ApplicationActivity subclass to
  skip creating a record (e.g., deduplicate by an ID in the payload).


## Contributing
Bug reports and pull requests are welcome.

## License
The gem is available as open source under the terms of the MIT License.


